{"pages":[{"title":"DataFil Documentation","text":"Welcome to the Wiki for this project. A convenient and reliable set of signal processing tools for developers to integrate into their project to better utilise the sensors on an iPhone. Creating a filter that has the right characteristics can be an extremely time consuming task, and often requires knowledge of signal processing. This library provides an alternative to that, with ready to use filters that can be customised and integrated into your application quickly and easily. Key features include: A consistent, easy to use interface and simple data model \u00e2\u0080\u009cDrag and drop\u00e2\u0080\u009d functionality. Each filter can operate as a standalone class. No project imports or external dependencies required. The latest Swift 3 syntax. Concurrent calculations where necessary. Showcase App How to Use the Showcase App Using an Apple Watch with the Showcase App Sensor Data Flow Management Tools Library Organisation Implementing Apple Watch Sensor Communication Using the Data Source Manager Using the Filter Manager Filter Algorithm Implementation How To Implement a Filter Algorithm Filter Protocol Data Point Object Algorithm Specifications High Pass Filter Low Pass Filter Bounded Average Filter Savitzky-Golay Filter Total Variation Denoising Filter","tags":"","url":"index.html"},{"title":"How to Use the Showcase App","text":"Introduction Each filter behaves differently, and is suited to different applications. To ease in the process of choosing the right filter for you, a showcase app is available that can be used to analyse and experiment with each filter to find the right configuration for your application. The app\u00e2\u0080\u0099s source code is available on GitHub, and it will be downloadable on the Apple App Store. Key Features The data displayed in the graph is the real-time output of the iPhone\u00e2\u0080\u0099s accelerometer in the x-axis by default, with a series for raw and processed data. The source and axis of the data can be changed by tapping the Settings button. Here the scale can be modified and the graph can be split into two, with one for raw and processed data respectively. Below is table of the available filters that can be applied to the data. Tapping on each one will reveal the configuration page for that filter. Here, the filter can be switched on and off, and the parameters modified. The changes to the filter settings are reflected on the graph in real time. Experiment with this to find a data output that works for your application. Some things to consider when choosing a filter and configuration: Is it more important that the amplitude or frequency of that acceleration be preserved? Do you want to remove noise from the data, or correct for bias caused by factors such as gravity? Is it more important to get fresh data or clean data? In other words, is the performance of the filter or quality of its output more Does the data change slowly over time, or quickly in bursts? Your answers to these questions should guide your choice, along with the observed be behaviour in the showcase app and information provided in this document. Each one of the above priorities lends itself to a different filter. The app allows the viewing and recording real-time data from the device\u00e2\u0080\u0099s sensors, which can be exported in JSON or CSV format. The format of the JSON and CSV export files can be seen below JSON Format { date: &quot;yyyy-MM-dd HH:mm:ss '+'ZZZZ&quot;, filters: { filterName: { paramName: DoubleValue } } processed: [ { ID:Int x:Int y:Int z:Int } ], raw: [ { ID:Int x:Int y:Int z:Int } ] } CSV Format ID,rawX,rawY,rawZ,processedX,processedY,processedZ Note that these patterns will be reproduced for every sensor active. This data can be emailed as a .txt attachment. To use this feature, tap the Record tab on the bottom of the app. Previously recorded captures can be accessed by tapping the Saved Captures button at the bottom of the data capture page. Here a table of captures is displayed, ordered by date. The data in the filters section of the JSON export can be used to configure the parameters of the filter upon implementation. Note that it is possible to enable more than one filter at once, and the order in which they are applied to the data will influence the output. As such, the order of the filters in the JSON output reflects the true order. For details on how to do this, see the Filter Interface section directly below. To export, tap on the desired capture, which will cause an email to be composed with the selected data attached. They can be removed from storage by swiping right and tapping delete.","tags":"","url":"Showcase_App\/How_to_Use_the_Showcase_App.html"},{"title":"Using an Apple Watch with the Showcase App","text":"The showcase app provides the functionality to stream data from a paired apple watch, which can then the graphed, filtered and recorded like local data. Install the application on the Apple Watch by navigating to the DataFil row in the apps section of the Watch app. To connect and start streaming, ensure the devices are paired, connected and unlocked, then: On the Watch Open the DataFil app. Press start streaming. This will begin the publishing of data to the iPhone once connected. On the iPhone Open the DataFil app and navigate to the watch tab. Ensure that the supported status is YES. Tap the connect button. Installation status and Listening for data should both turn to YES. In the settings of the graph, the device input can now be switched between iPhone and Watch. At the top of the data recording view, the data source to collect from can now also be switched between.","tags":"","url":"Showcase_App\/Using_an_Apple_Watch_with_the_Showcase_App.html"},{"title":"Implementing Apple Watch Sensor Communication","text":"The communication of data to and from the Apple Watch is handled using the following classes, found in the globalModel group: RemoteDataInterface Serialiser RemoteCommunicator The stack is symmetrical, meaning that the same code can be used to start a session from both devices. In the following sections, each class in the stack is described. Remote Communicator The RemoteCommunicator class is the lowest level in this process, used to manage the communication session with the remote device, and is independent of any other part of the application, meaning it can be used to send any arbitrary message to and from the watch. Messages are sent as a key value pair, and observers can subscribe to be notified when a message with a matching key arrives. This allows messages of different types to be sent and received to specific parts of the application without the need to determine if a specific message is relevant in the main logic of the application. Each observing communicator can assume that if it is notified of a message that it was intended for them. The class is instantiated with a deviceId, for debugging purposes, allowing the source devices of console messages to be traced. It also contains several methods for checking if the remote partner is connected and reachable. Function Summary Start func start(deviceId: String) Attempts to start a session with the remote device. Should this not be possible an error message will be printed to the console. This method must be called before attempting communication. isSupported func isSupported() -&gt; Bool Returns a Boolean detailing if Apple Watch communication is supported by the device. watchIsConnected func watchIsConnected() -&gt; Bool Returns a Boolean detailing if an Apple Watch is connected and can be reached for communication. sendMessage func sendMessage(key: String, value: Any) Attempts to send a message with key and value passed into the function to the remote device. If this fails, a message will be printed to the console. On the remote device, any observer subscribed to messages with the matching key will be notified of the contents. addObserver func addObserver(key: String, update: @escaping (Any) -&gt; Void) Adds a callback from an observing class that will be called when a message with a matching key arrives from the remote device. It must accept any object as this is what can be passed into the sendMessage function on the remote partner. Remote Data Interface Next in the stack is the logic specific to sending and receiving sensor data. This is the responsibility of the remoteDataInterface. It can be used to send outgoing sensor data to the remote partner, by observing for new local data though the same observer system used for all consumers. The remoteDataInterface can observe to the remoteCommunicator class to listen for new incoming remote data, which will arrive under a specific key. When listening, it will notify other consumers of sensor data using the same notification format as local sensor data notifications, meaning that any consumer of local data can be trivially switched to listen for remote data. This symmetry of the communication hierarchy and uniform processing of remote and local data means that if desired, the watch could listen for sensor data from the iPhone, or even another watch. There is no pre-defined rigid data flow. Note that remoteDataInterface is a singleton. Function Summary publishOutgoingData func publishOutgoingData() When called the class will begin attempting to send new raw data published by the dataSourceManager to the remote device. Can be used to send raw data from the Apple Watch to the iPhone. subscribeIncomingData func subscribeIncomingData() Will cause the device to start listening to messages sent from the publishOutgoingData function on the remote device. When received, the data will be published globally under a notification named newRemoteData. Serialiser It is important to note that it is not possible simply to send accelPoint objects to a remote device. The communication protocol defined by Apple can only accept primitive objects such as Strings, Doubles and Integers. For this reason, the remoteDataInterface will serialise each accelPoint, using the Serialiser class before sending. When receiving, it will de-serialise the incoming primitive back into an accelPoint object before notifying consumers of this data. This process is transparent to the sender and receiver of the sensor data, and part of the hierarchical design of the communication. These functions do not need to be called directly, they are used as required by the remoteDataInterface for sending and receiving. Function Summary serialise serialise(input: accelPoint) -&gt; String Will convert a valid accelPoint object into a String for sending. Reversed with deserialise. deserialise deserialise(input: String) -&gt; accelPoint Will convert a valid String into an accelPoint object. Reverse of serialise function.","tags":"","url":"Sensor_Data_Flow_Management_Tools\/Implementing_Apple_Watch_Sensor_Communication.html"},{"title":"Using the Data Source Manager","text":"The dataSourceManager provides a tool to manage the sensor capabilities of the device. When enabled, it will create accelPoint objects that contain all the available sensor data, numbered sequentially. It can be instantiated on either an iOS or Watch OS device, and when running will post notifications under the name newRawData, that can be observed for globally that contain the latest accelPoint object. The filterManager class is set up by default to observe for these notifications for data to process. To change sensor sample rate, a notification of the following format can be posted from anywhere in the application, where sampleRate is the double value of the desired rate: NotificationCenter.default.post( name: Notification.Name(&quot;newDatasourceSettings&quot;), object: nil, userInfo:[&quot;sampleRate&quot;:sampleRate] ) The function to extract the accelPoint would then be as follows: @objc func newRawData(notification: NSNotification){ let data = notification.userInfo as! Dictionary&lt;String,accelPoint&gt; let accelData = data[&quot;data&quot;] } Function Summary Initialiser init(sourceId: String) The source ID will be printed alongside any debugging statements to identify the source of the message, to ease development when working with remote devices. InitaliseDataSources func initaliseDatasources() When called, the dataSourceManager will attempt to startup all available sensors on the device. When ready, it will begin posting this data as accelPoint objects, in notifications under the name newRawData. As such, this data could be observed for using the following code: NotificationCenter.default.addObserver(self, selector: #selector(FilterManager.newRawData), name: Notification.Name(&quot;newRawData&quot;), object: nil) deinitDataSources func deinitDatasources() When called, the dataSourceManager will stop posting notifications with new raw data and will stop requesting sensor updates from the system. Should be used when data is no longer required to conserve power. modifyDataSources func modifyDataSources(accel:Bool,gyro:Bool,mag:Bool) Used to choose the active sensors. Unneeded sensors should be disabled using this method to conserve power. Placeholder 0 values will be used in the disabled sensor fields of posted accelPoints","tags":"","url":"Sensor_Data_Flow_Management_Tools\/Using_the_Data_Source_Manager.html"},{"title":"Using the Filter Manager","text":"The filterManager class provides a convenient way to manage the flow of sensor data through your application, particularly if using more than one filter simultaneously. It allows for filters to be connected to each other, and for data to be sent from the sensor source by notification. The addition of the filter manager to your project allows raw data to be directed into and processed data out of the filters with minimal modification to your existing code. To apply a filter using filterManager: filterManager is a singleton, so once the singleton is initialised it can be referred to globally. Data can be directed at the filterManager by passing it in a notification with the following format. Initialising the filterManager will cause it to observe for this notification. Using the dataSourceManager class will direct sensor data at the class automatically using this system. name:\u00e2\u0080\u009dnewRawData\u00e2\u0080\u009d userInfo: [\u00e2\u0080\u009cdata\u00e2\u0080\u009d:accelPoint] To enable a filter, simply pass the name of the filter as described in the details below to the function addNewFilter, using the Algorithm enum. This can be done multiple times to add as many filters as required. This will cause the filter manager to post notifications with the processed data from this filter with a name newProcessedData. The workflow above describes the initial setup of the manager. The complete set of functions is described in the documentation for this class below. While filterManager can make using the included algorithms easier, it is optional. All filters will function without it. To see an example of how the filterManager can be linked between your data sources and sinks, see the showcase app code. Example Set Up Below is an example set up of the filterManager. To set up three filters, in order, we would execute: let filMan = filterManager.sharedInstance() filMan.addNewFilter(Algorithm.HighPass) filMan.addNewFilter(Algorithm.LowPass) filMan.addNewFilter(Algorithm.BoundedAverage) To remove a filter and replace it with another, we would execute: filMan.removeFilter(Algorithm.BoundedAverage) filMan.addNewFilter(Algorithm.SavitzkyGolay) To the other parts of the system the data flow remains unchanged. The data source and sink are unaware of this change to the system, effectively maintaining separation between our model, controller and view layers. Variable Summary | Name and Type | Description | || |------------------------------------------------ |----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | || | SharedInstance:FilterManager (static constant) | Singleton variable for the class || | activeFilters:[Filter] | Array of objects that implement the Filter protocol, that raw or partially processed data will be passed to. The filter manager expects these objects to eventually return an accelPoint and is listening for this. || Function Summary observeRemoteData func observeRemoteData() Will cause the system to start listening for new data from a paired Apple Watch through the use of the newRemoteData notification posted by the remoteDataInterface class. Stops listening for local data from the dataSourceManager observeLocalData func observeLocalData() Will cause the system to start listening for local data from the dataSourceManager. Active by default, can be used to switch back from remote data observance. addNewFilter func addNewFiler(AlgorithmToAdd: Algorithm) This function is used to activate a new filter. The Algorithm enum is used to identify the filter to activate. When a filter is active, the newProcessedData notification will contain the convoluted output of the raw data and active filters. newRawData \u00c2 @objc func newRawData(notification: NSNotification) Function nominated by the selector of the observer for new raw data from any source. Expects data to be passed in userData as: notification.userInfo as! Dictionary&lt;String,accelPoint&gt; This function will only ever be called in response to a notification from an observed data source. To enable this, it must be exposed to objective-C, through the @objc annotation. When called, the function will pass the data into the chain of filters. If no filters are present, it will pass the raw data directly to the output. removeFilter func removeFilter(name: Algorithm) Function will deactivate the filter with the given name, if active. This will cause the data flow to bypass this filter, and either go to the next in the chain or the output. setFilterParamater func setFilterParameter(filterName: Algorithm, parameterName: String, parameterValue: Double) If active, this function will find the named filter and set the named parameter to the described value. This can be executed at any time. All filters will accept new parameters and update accordingly at any point. A filter may complain if an invalid parameter is passed in, however it is important to check the values being passed in fall within acceptable range. For more information check the specification of the filter in question. receiveData func receiveData(data: [accelPoint], id:Int) This function is called by active filters when they have new data to pass on. This can happen at any point. If there is processed data available to be passed to the data sink, a notification with the name newProcessedData will be made, with the new data points in the userData of the notification. This will have the format: notification.userInfo as! Dictionary&lt;String,accelPoint&gt; Note that the amount of new points can be any non-zero value, and that every call to receive data may not result in a notification for new data. To collect processed data, your application should observe these notifications.","tags":"","url":"Sensor_Data_Flow_Management_Tools\/Using_the_Filter_Manager.html"},{"title":"accelPoint Data Object","text":"An accelPoint object represents an instantaneous sensor reading, with X Y and Z values. Distinct points should be given unique IDs. This ID may be for example a sequence number or a timestamp of the reading. Initialisation using the default initialiser will set all values, including ID to 0. accelPoints are used as the data model input and output for the filter algorithms, and is designed to be similar in function to Apple\u00e2\u0080\u0099s implementation. Variable Summary | Name and Type | Description | || |--------------- |----------------------------------------------------- || | xAccel:Double | Acceleration in the x axis in ms2 || | yAccel:Double | Acceleration in the y axis in ms2 || | zAccel:Double | Acceleration in the z axis in ms2 || | xGyro:Double | Rotational velocity in x axis in rad\/sec || | yGyro:Double | Rotational velocity in y axis in rad\/sec || | zGyro:Double | Rotational velocity in z axis in rad\/sec || | xMag:Double | Magnetic field in x axis in militeslas || | yMag:Double | Magnetic field in y axis in militeslas || | zMagDouble | Magnetic field in z axis in militeslas | || | Count:Int | The identification number of the acceleration point | || Function Summary get$Axis func getAccelAxis(axis: String) -&gt; Double func getGyroAxis(axis: String) -&gt; Double func getMagAxis(axis: String) -&gt; Double Utility function used to allow data access to be configured by a string, in a similar fashion to the parameter stinging functionality provided in accelPoint. Allows for runtime changes to the axis of data that is being filtered or accessed.","tags":"","url":"Filter_Algorithm_Implementation\/accelPoint_Data_Object.html"},{"title":"Filter Implementation","text":"Introduction This section describes in detail how to interact with the filters in your application. Every filter included has the same interface, as defined by the FilterProtocol. The filters should only be interacted with through this interface, as while they may have other methods publicly visible for testing purposes, these methods will not configure the filter state correctly, and may lead to poor data or crashes. Algorithm Enumeration Each filter algorithm is identified through the use of the Algorithm enum. It contains the following values: HighPass LowPass BoundedAverage SavitzkyGolay TotalVariation Functions described elsewhere, such as addNewFilter require the use of this enum to identify the filter to activate, and should therefore be included in the project. Algorithm.x.description will return an English full name of the filter. Setup and Use Every filter depends on 3 key items, which should be included in your project: accelPoint class Filter protocol Algorithm enum Some filters may have additional dependencies that must be imported alongside the file. These will be specified in the section of the documentation pertaining to that filter and the class itself. Once the required files have been imported into your project, the filter will be ready for use. The following workflow will then apply: Create a new filter object, using the default initialiser. As each filter will have an internal state, it is important that a filter is only used for one data stream at a time. New objects should be created to filter data from multiple sources at once. Add a callback to the filter, using the addSubscriberCallback function. Create an accelPoint object with the data to be filtered, and pass it into the filter object using the addDataPoint function Registered observer callbacks will be called with new data when it is ready.","tags":"","url":"Filter_Algorithm_Implementation\/Filter_Implementation.html"},{"title":"Filter Protocol","text":"Every filter implements this protocol, and as such it should be included in any project utilising them. It defines a standard interface that each filter will conform to. Below is a list of function definitions and their description. Variable Summary Name and Type Description filterName:Algorithm Get only. The full English name of the filter Params: [String:Double] Get only. A dictionary with parameter name and values as key value pairs. Observers:[(_:[accelPoint])-&gt;Void] Get only. A list of callbacks that should be executed when new data is available. Function Summary addDataPoint func addDataPoint(dataPoint:accelPoint) -&gt; Void Void function used to add a data point to the filter to be processed. Filter expects a unique ID, and all values to be set. addObserver func addSubscriberCallback(update: @escaping (_: [accelPoint])-&gt; Void) Void function used to add a callback closure to the filter as an observer. The added observer will be executed when new processed data is available. This call will always be made on the main thread, but may be made at any time after adding a data point. It may contain any number of accelPoints as an array, that contain the same ID as their raw counterpart but the processed values for x, y, z. The returned accelPoint object will not be same as the last one passed in, and may have a different ID, as some filters buffer values. The closure has the @escaping attribute as it will be executed after the addSubscriberCallback function has returned. It must accept an argument named data:[accelPoint] and return void. notifySubscribers func notifySubscribers(data: [accelPoint]) Function called by the algorithm in the filter class to signal that new data is ready. The function should be implemented to execute all closures stored in the observers property of the filter. It will pass through a non-empty array of accelPoint objects into the closures. Each accelPoint will contain the filtered data with the matching ID of the raw data counterpart. setParameter func setParameter(parameterName:String, parameterValue:Double) -&gt; Void Used to modify the parameters of the filtering algorithm. This can be done at any time during the filter\u00e2\u0080\u0099s lifetime to override the default values. A list of the parameters each filter contains can be found their section of this document.","tags":"","url":"Filter_Algorithm_Implementation\/Filter_Protocol.html"},{"title":"Bounded Average Filter","text":"Introduction, Usage and Behaviour This filter functions by taking a moving average of a previous values and determining if it falls within a set of parameterised bounds. If it does, it outputs a value in the middle of those bounds. If it does not, the new middle value is set to the raw data value, and the bounds recreated. This results in a filter that outputs a steady signal until a threshold is met, at which point the output jumps instantaneously until the in-bounds property is recovered. This filter would be well suited to situations where: The signal to noise ratio is fixed. The bounds of the filter can be set just larger than the noise level, resulting in a very clean, steady signal. The input data is a binary signal combined with some amount of noise. This filter is effective at recovering the original binary signal. Like the binary data, the output signal will fall into categories. For example magnetometer data to the directions on a compass rose. The output will be a steady signal in one of the points, and will quickly and precisely jump to the next point when the signal dictates. Complexity: Filter application: O(n) where n = number of points to consider in average. Memory load: Filter application: O(n) where n = number of points to consider in average. While the algorithm does not run in constant time, the number of historical points to consider is likely small. The algorithm can run with 0 previous values considered. Parameters Name and Type Description upperBound:Double Range: 0...8 The upper bound beyond which the signal centre is reset and the bounds shift upwards. lowerBound:Double Range: 0...8 The lower bound beyond which the signal centre is reset and the bounds shift downwards. pointsAverage:Double Range: 0...n The number of points to consider in the moving average. Determines complexity. The figures above show that the bounds size must be carefully matched to the expected accelerations in the application. If there are too small, the data is noisy and has many artefacts. If the bounds are too large, changes in the data are lost, and the bounds can settle at an inaccurate value. Testing Tests for this filter can be found in the boundedAverageTests.swift file.","tags":"","url":"Algorithm_Specifications\/Bounded_Average_Filter.html"},{"title":"High Pass Filter","text":"Introduction, Usage and Behaviour The high pass filter is the simplest of the filtering algorithms included in the library, but is extremely useful. The filter functions by allowing high frequency signals to pass, but removing low frequency ones. This makes it useful for isolating and removing bias in a signal such as gravity. It does not however remove high frequency noise that is often characteristic of MEMS sensors. Complexity: Coefficient Calculation: O(1) Filter application: O(1) Memory load: Coefficient Calculation: O(1) Filter application: O(1) The complexity and memory requirements of this filter are constant and trivial. At any one time the algorithm keeps track of the previous raw and processed value. Parameters Name and Type Description CutPoint:Double Range: 0...10 Frequency at which the signal is attenuated. The lower this value, the lower the frequency of a signal needs to be to be attenuated. This results in a less active filter that takes longer to return to zero after displacement. Freq:Double The frequency of the sampling source. This is used in the coefficient calculation. It can be seen that when a small cut-off frequency is used, the time taken for the filter to bring the signal back to 0. At very high values we can see that this is almost instantaneous. When working with this filter it is important to strike a balance between responsiveness and over activity cutting out useful data. Testing Tests for this filter can be found in the highPassTests.swift file.","tags":"","url":"Algorithm_Specifications\/High_Pass_Filter.html"},{"title":"Low Pass Filter","text":"Introduction, Usage and Behaviour This filter is conceptually the opposite of the high pass filter. It allows low frequency signals to pass through, while removing and smoothing out the high frequency ones. This makes it useful for removing noise from a signal. This filter is generic, and uses a coefficients generation algorithm to create a transfer function based on the parameters passed in, using a mathematical recipe. This means the filter is capable of behaving as several kinds of filter: Butterworth Designed to have a completely flat frequency response in the accepted range. This means that it treats all signals in the accepted range exactly the same.(Unicorn Trading Company, n.d.) It is prone to overshooting however. This means that the processed signal can temporarily exceed the amplitude of the raw signal if it changes quickly, this can be seen in the image below.(Butterworth S, 1930) Critically Damped A critically damped filter is designed to remove the overshooting effect seen in the Butterworth filter. The compromise however, is that a delay is introduced on the processed data when a rapid change in the raw data occurs. In the image below we can see that the overshoot is removed but the ascending and descending leg of the filter lag behind the raw data considerably. Bessel This filter interferes the least with the frequencies in the accepted frequency range, and will not overshoot. It is a compromise between the significant suppression of the critically damped filter and the more active Butterworth filter. The number of passes can be varied from 1 to 3, allowing the filter to be cascaded. Cascading filters can intensify their behaviour. For example, cascading the Butterworth filter will significantly increase the amount of overshoot. Cascading the critically damped filter will not cause it to overshoot. It will maintain the critical damping property. Overall, this filter is considerably more complex, particularly for the coefficients generation section of the algorithm, although this can be run only once. It does however offer a considerable amount of flexibility. Note that when the filter is started, the output signal will briefly drop to 0. This is normal and is part of the filter\u00e2\u0080\u0099s start-up routine. To avoid issues with data, start the filter before it is required to process data to ensure that it is ready. Complexity: Coefficient Calculation: O(1) Filter application: O(n) where number n = of passes on filter. Memory load: Coefficient Calculation: O(1) Filter application: O(1) - Changing the number of passes does not change the memory usage of the filter. Parameters Name and Type Description n:Double Range: 1...3 Defines the number of passes of the filter. Increasing will cause the filter to cascade. p:Double Range: 0.2...5 Polynomial coefficient partially defining the transfer function of the filter. A lower p makes the filter more responsive, decreasing the smoothing effect of the filter, but also reduces lag in sudden changes. Decreasing below 1 will cause resonating amplification. If an order larger than 1 is used simultaneously it will occur increasing amounts indefinitely until overflow occurs. g:Double 0.2...5 Gain constant of the filter, forming part of the transfer function, defines the values that make the transfer function return 1 when passed 0. A larger G will reduce lag, but may lead to overshoot. A value of G below 1 for any value of P above 1 will result in a critically damped filter. Suggested Parameter Setup Filter Name n p g Butterworth 1 1.4 1 Critically Damped 1\u00e2\u0080\u00a63 2 1 Bessel 1 3 3 Linkwitz-Riley* 2 1.4 1 The mathematics and parameter set up for this filter are described Here. More information on Linkwitz-Riley filter Testing Tests for this filter can be found in the advancedLowPassTests.swift file.","tags":"","url":"Algorithm_Specifications\/Low_Pass_Filter.html"},{"title":"Savitzky Golay Filter","text":"Introduction, Usage and Behaviour This filter is different from the previous three, in that it is non-casual. This means that it must consider both future and previous points when calculating the smoothing of the current point. This has advantages and drawbacks, the most obvious of which is that it introduces a delay proportional to the number of future points being considered. The main advantage however is a more nuanced smoothing function that helps to maintain the amplitude and frequency of the input data, but is very effective at increasing the signal-to-noise ratio. The filter functions through the use of convolution. Using linear algebra to apply a curve fitting of a second or forth degree polynomial to the data. The coefficients are calculated beforehand, by creating an imaginary curve with length n+1, where n is the number of the points to the left and right being considered. In this imaginary list, all points are set to zero apart from the centre, which is set to 1. The values of the polynomial curve that are created about this point become the coefficients that are applied to the raw data values at runtime. The calculated coefficients are applied through the use a of a simple weighted moving average to the left and right of the point in consideration. This makes the filter computationally light at runtime. Complexity: Coefficient Calculation: O((nl+nr)^m) where nl = leftScan and nr = rightScan and m = polynomial order (2 or 4) Filter application per point: O(nl+nr) where nl = leftScan and nr = rightScan Memory load: Coefficient Calculation: O((nl+nr)^m) where nl = leftScan and nr = rightScan and m = polynomial order (2 or 4) Filter application per point: O(nl+nr) where nl = leftScan and nr = rightScan Parameters Name and Type Description leftScan:Double Range: 1...n Defines the number of future,points that should be considered when calculating the current point. The larger this value, the larger the delay. A large difference between the left and right range can lead to anomalous behaviour. A forward scan value slightly larger than a backward scan value can reduce under and overshoot on sudden changes. rightScan:Double Range: 1...n Defines the number of historic points to be considered when calculating the current point. Does not affect delay. Does increase memory use. A higher value results in a smoother output. filterPolynomial:Double (rightScan+leftScan+1)...n The order of the polynomial used to calculate the coefficients. A higher order polynomial filter will respond better to high amplitude changes. Note that this value must be larger than (nr+nl+1) or no filtering will be applied. An error will be displayed in the console. The above graphs are examples of a good and two bad configurations of this filter. The first above shows well how a properly calibrated filter will preserve the height and width of major movements in the data. The second displays anomalous changes on the descending and ascending leg of the major movement due to a low order being used with comparatively high numbers of points being considered. Lastly, the third shows a configuration where the polynomial is too low, and the number of points considered too high for the frequency of change present in the data. The height and width of the data is lost. Testing Tests for this filter can be found in the savGolTests.swift file","tags":"","url":"Algorithm_Specifications\/Savitzky_Golay_Filter.html"},{"title":"Total Variation Denoising Filter","text":"Introduction, Usage and Behaviour This is yet another style of filter that is better suited to batch processing of data. This means that if for example you are recording data and not using it in real time, this filter can be used to yield an extremely clean signal, by passing in all the data at once. For the purposes of the live demo, the data points are batched together in a buffer and processed in groups of size 10 to 1000. The larger the batch size, the longer the lag, but the more consistent the output data. This filter is an implementation of the total variation denoising method proposed in \u00e2\u0080\u009cLaurent Condat. A Direct Algorithm for 1D Total Variation Denoising. 2013.\u00e2\u0080\u009d Broadly, the filter operates by creating a value that it tries to preserve for as long as possible, as it moves through the data. For as long as it can do this, the generated value is set as the output at that point. If it cannot preserve, it backtracks to a point where a new value can be generated, set it as the new point to preserve and continues. (Condat, 2013). More information on the detailed operation can be found in the paper mentioned above. The output of this filter is a flat value, with instant jumps to new values, similar in style to the output of the bounded average filter. The filter only considers values looking forward from its current position in the dataset, meaning that memory usage is minimal. It also means however that the output is sensitive to the size of the input dataset. Therefore, the maximum allowable dataset size should be passed in. This filter can be combined with low pass filter to great effect. The clean output of the total variation filter is combined with the smoothing effect of the low pass algorithm to create a clean, smooth signal that responds quickly and decisively to change, making the combination ideal for applications such as games where specific movements are triggered by accelerometer events. Complexity: Filter application: O(n^2) where n = number of points in the input dataset. Memory load: Coefficient Calculation: O(n^2) where n = number of points in the input dataset. Information on the complexity of this algorithm is provided in the paper discussed above. (Condat, 2013) When using this filter in the showcase app, the graph may appear to freeze. This is normal behaviour, and the graph will update with new values as they are batch processed. This effect can be reduced by selecting a smaller batch size. The live raw data can be viewed by tapping settings and then unchecking Single Raw &amp; Filtered Graph. The bottom graph will update in jumps as new processed data becomes available. Parameters Name and Type Description lambda:Double Range: 0.01...1 Defines the sensitivity of the filter to changes in value. The larger the lambda value, the larger change in acceleration is required to trigger an update of the output value. It also causes instantaneous jumps to be larger when they occur. This should be tested to a value that is above the level of noise in your data but below the magnitude of changes that are considered meaningful. bufferSize:Double Range: 1...n Defines the size of the batch to be processed at once. When using the filter for real-time applications this will define the delay. For efficiency and output data consistency, the largest acceptable value should be used. The sample graphs above show some of the characteristic behaviour of the total variation denoising filter. The first displays clearly how the overall movement in the data is isolated by removing extreme peaks and troughs. It also shows the flat tops at the maxima and minima of the data, characteristic of this algorithm. The middle is included to clearly display the way in which the filter behaves with sudden changes. It can be seen that a single instantaneous jump was made from the old signal value to the new. The effect of selecting a smaller batch size can be seen in the last image. Compared to the first, the processed data more closely resembles the raw data, and the flat tops at maxima and minima are smaller and less clear. Testing Tests for this filter can be found in the totalVarTests.swift file","tags":"","url":"Algorithm_Specifications\/Total_Variation_Denoising_Filter.html"},{"title":"Library Organisation","text":"The library provided here consists of two main components. First, the filter algorithms, which can all be found in the Filters group of the project. Note that these filters are compatible with all iOS and Mac OS devices, including the Apple Watch and can be used in isolation from the rest of the project. Second is the supporting code that can be used to aid the use of sensor data in your application. All of these classes can be found in the globalModel group of the project. These are classes that have been specifically designed to run on iOS and Watch OS devices, and include features such as a communication stack for streaming sensor data from an Apple Watch and a class for comprehensive sensor management. These are discussed further in the following sections.","tags":"","url":"Library_Organisation.html"},{"title":"Contents","text":"Introduction Showcase App How to Use the Showcase App Using an Apple Watch with the Showcase App Sensor Data Flow Management Tools Library Organisation Implementing Apple Watch Sensor Communication Using the Data Source Manager Using the Filter Manager Filter Algorithm Implementation How To Implement a Filter Algorithm Filter Protocol Data Point Object Algorithm Specifications High Pass Filter Low Pass Filter Bounded Average Filter Savitzky-Golay Filter Total Variation Denoising Filter","tags":"","url":"Contents.html"}]}